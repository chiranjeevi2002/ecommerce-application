package com.ecommerce.orderservice.service.impl;

import com.ecommerce.orderservice.client.InventoryClient;
import com.ecommerce.orderservice.client.PaymentClient;
import com.ecommerce.orderservice.client.ProductClient;
import com.ecommerce.orderservice.dto.OrderDTO;
import com.ecommerce.orderservice.enums.OrderStatus;
import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.service.OrderCancellationService;
import com.ecommerce.orderservice.service.OrderDomainService;
import com.ecommerce.orderservice.service.OrderWorkflowService;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.util.List;

@Service
public class OrderWorkflowServiceImpl implements OrderWorkflowService {

    private final OrderDomainService domain;
    private final ProductClient product;
    private final InventoryClient inventory;
    private final PaymentClient payment;
    private final OrderCancellationService cancellation;

    public OrderWorkflowServiceImpl(
            OrderDomainService domain,
            ProductClient product,
            InventoryClient inventory,
            PaymentClient payment,
            OrderCancellationService cancellation
    ) {
        this.domain = domain;
        this.product = product;
        this.inventory = inventory;
        this.payment = payment;
        this.cancellation = cancellation;
    }

    // --------------------------------------------------
    // CREATE ORDER
    // --------------------------------------------------
    @Override
    public Mono<Order> createOrder(Long userId, Long storeId, OrderDTO dto) {

        var productIds = extractProductIds(dto);

        return product.validateProducts(storeId, productIds)
                .filter(r -> r.valid())
                .switchIfEmpty(Mono.error(new IllegalStateException("Invalid products in order")))

                .then(createOrderEntity(dto, userId, storeId))

                .flatMap(order ->
                        reserveInventory(dto, storeId)
                                .then(updateStatus(order, storeId, OrderStatus.INVENTORY_RESERVED))
                                .thenReturn(order)
                )

                .flatMap(order ->
                        initiatePayment(order, storeId)
                                .then(updateStatus(order, storeId, OrderStatus.PAYMENT_PENDING))
                                .thenReturn(order)
                );
    }

    @Override
    public Mono<Order> finalizePayment(Long orderId, Long storeId, boolean success) {

        var status = success
                ? OrderStatus.PAYMENT_COMPLETED
                : OrderStatus.PAYMENT_FAILED;

        return updateStatus(orderId, storeId, status)
                .flatMap(order ->
                        success
                                ? updateStatus(orderId, storeId, OrderStatus.CONFIRMED)
                                : Mono.just(order)
                );
    }

    @Override
    public Mono<Order> cancelOrder(Long orderId, Long userId, Long storeId) {

        return getOrder(orderId, storeId)

                .filter(o -> o.getUserId().equals(userId))
                .switchIfEmpty(Mono.error(new SecurityException("Unauthorized")))

                .filter(o -> cancellation.isCancelable(o.getStatus()))
                .switchIfEmpty(Mono.error(new IllegalStateException("Order not cancellable")))

                .flatMap(order ->
                        cancellation.rollbackInventory(order, storeId)
                                .then(cancellation.rollbackPayment(order, storeId))
                                .then(updateStatus(order.getId(), storeId, OrderStatus.CANCELLED))
                );
    }

    private List<Long> extractProductIds(OrderDTO dto) {
        return dto.items().stream()
                .map(i -> i.productId())
                .toList();
    }

    private Mono<Order> createOrderEntity(OrderDTO dto, Long userId, Long storeId) {
        return Mono.fromCallable(() -> domain.create(dto, userId, storeId))
                .subscribeOn(Schedulers.boundedElastic());
    }

    private Mono<Void> reserveInventory(OrderDTO dto, Long storeId) {
        return Flux.fromIterable(dto.items())
                .flatMap(i ->
                        inventory.decrease(
                                i.productId(),
                                i.quantity(),
                                storeId
                        )
                )
                .then();
    }

    private Mono<Void> initiatePayment(Order order, Long storeId) {
        return payment.initiatePayment(
                order.getId(),
                order.getUserId(),
                order.getTotalAmount(),
                storeId
        ).then();
    }

    private Mono<Order> updateStatus(Order order, Long storeId, OrderStatus status) {
        return updateStatus(order.getId(), storeId, status);
    }

    private Mono<Order> updateStatus(Long orderId, Long storeId, OrderStatus status) {
        return Mono.fromCallable(() -> domain.updateStatus(orderId, storeId, status))
                .subscribeOn(Schedulers.boundedElastic());
    }

    private Mono<Order> getOrder(Long orderId, Long storeId) {
        return Mono.fromCallable(() -> domain.get(orderId, storeId))
                .subscribeOn(Schedulers.boundedElastic());
    }
}
