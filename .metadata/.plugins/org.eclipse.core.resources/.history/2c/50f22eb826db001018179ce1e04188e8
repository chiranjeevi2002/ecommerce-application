package com.ecommerce.orderservice.service.impl;

import com.ecommerce.orderservice.client.InventoryClient;
import com.ecommerce.orderservice.client.PaymentClient;
import com.ecommerce.orderservice.client.ProductClient;
import com.ecommerce.orderservice.dto.OrderDTO;
import com.ecommerce.orderservice.enums.OrderStatus;
import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.service.OrderDomainService;
import com.ecommerce.orderservice.service.OrderWorkflowService;

import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;

@Service
public class OrderWorkflowServiceImpl implements OrderWorkflowService {

	private final OrderDomainService domainService;
	private final ProductClient productClient;
	private final InventoryClient inventoryClient;
	private final PaymentClient paymentClient;

	public OrderWorkflowServiceImpl(OrderDomainService domainService, ProductClient productClient,
			InventoryClient inventoryClient, PaymentClient paymentClient) {
		this.domainService = domainService;
		this.productClient = productClient;
		this.inventoryClient = inventoryClient;
		this.paymentClient = paymentClient;
	}

	@Override
	public Mono<Order> createOrder(Long userId, Long storeId, OrderDTO dto) {

		return Mono.defer(() -> {
			dto.items().forEach(item -> productClient.checkProduct(item.productId(), storeId));
			return Mono.fromCallable(() -> domainService.create(dto, userId, storeId))
					.subscribeOn(Schedulers.boundedElastic());
		}).flatMap(order -> reserveInventory(dto, storeId).then(update(order, storeId, OrderStatus.INVENTORY_RESERVED))
				.thenReturn(order))
				.flatMap(order -> initiatePayment(order, storeId)
						.then(update(order, storeId, OrderStatus.PAYMENT_PENDING)).thenReturn(order));
	}

	private Mono<Void> reserveInventory(OrderDTO dto, Long storeId) {
		return Flux.fromIterable(dto.items())
				.flatMap(item -> inventoryClient.decrease(item.productId(), item.quantity(), storeId)).then();
	}

	private Mono<Void> initiatePayment(Order order, Long storeId) {
		return paymentClient.initiatePayment(order.getId(), order.getUserId(), order.getTotalAmount(), storeId).then();
	}

	private Mono<Order> update(Order order, Long storeId, OrderStatus status) {
		return Mono.fromCallable(() -> domainService.updateStatus(order.getId(), storeId, status))
				.subscribeOn(Schedulers.boundedElastic());
	}

	@Override
	public Mono<Order> finalizePayment(Long orderId, Long storeId, boolean success) {
		OrderStatus status = success ? OrderStatus.PAYMENT_COMPLETED : OrderStatus.PAYMENT_FAILED;

		return Mono.fromCallable(() -> domainService.updateStatus(orderId, storeId, status)).flatMap(order -> {
			if (success) {
				return Mono.fromCallable(() -> domainService.updateStatus(orderId, storeId, OrderStatus.CONFIRMED))
						.subscribeOn(Schedulers.boundedElastic());
			}
			return Mono.just(order);
		}).subscribeOn(Schedulers.boundedElastic());
	}

	@Override
	public Mono<Order> cancelOrder(Long orderId, Long userId, Long storeId) {

		return Mono.fromCallable(() -> domainService.get(orderId, storeId)).subscribeOn(Schedulers.boundedElastic())
				.doOnNext(order -> {
					if (order.getUserId().equals(userId)) {
						return;
					}
				})

				.flatMap(order -> {
					if (!isCancelable(order.getStatus())) {
						return Mono.error(
								new IllegalStateException("Order cannot be cancelled in state " + order.getStatus()));
					}
					return Mono.just(order);
				})

				.flatMap(order -> rollbackInventory(order, storeId).thenReturn(order))

				.flatMap(order -> rollbackPayment(order, storeId).thenReturn(order))
				.flatMap(order -> Mono
						.fromCallable(() -> domainService.updateStatus(order.getId(), storeId, OrderStatus.CANCELLED))
						.subscribeOn(Schedulers.boundedElastic()));
	}

}
