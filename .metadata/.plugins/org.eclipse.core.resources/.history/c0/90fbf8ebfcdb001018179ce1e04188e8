package com.ecommerce.orderservice.service.impl;

import com.ecommerce.orderservice.client.InventoryClient;
import com.ecommerce.orderservice.client.PaymentClient;
import com.ecommerce.orderservice.client.ProductClient;
import com.ecommerce.orderservice.dto.OrderDTO;
import com.ecommerce.orderservice.enums.OrderStatus;
import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.service.OrderCancellationService;
import com.ecommerce.orderservice.service.OrderDomainService;
import com.ecommerce.orderservice.service.OrderWorkflowService;

import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

@Service
public class OrderWorkflowServiceImpl implements OrderWorkflowService {

    private final OrderDomainService domainService;
    private final ProductClient productClient;
    private final InventoryClient inventoryClient;
    private final PaymentClient paymentClient;
    private final OrderCancellationService cancellationService;

    public OrderWorkflowServiceImpl(
            OrderDomainService domainService,
            ProductClient productClient,
            InventoryClient inventoryClient,
            PaymentClient paymentClient,
            OrderCancellationService cancellationService) {

        this.domainService = domainService;
        this.productClient = productClient;
        this.inventoryClient = inventoryClient;
        this.paymentClient = paymentClient;
        this.cancellationService = cancellationService;
    }

    // ---------------------------------------------------------
    // CREATE ORDER (Customer flow)
    // ---------------------------------------------------------
    @Override
    public Mono<Order> createOrder(Long userId, Long storeId, OrderDTO dto) {

        return Mono.defer(() -> {

            // using webClient Validate products synchronously (fail fast)
            dto.items().forEach(item ->
                    productClient.checkProduct(item.productId(), storeId)
            );

            // 2️⃣ Create order (blocking DB → boundedElastic)
            return Mono.fromCallable(() ->
                    domainService.create(dto, userId, storeId)
            ).subscribeOn(Schedulers.boundedElastic());

        })
        // 3️⃣ Reserve inventory
        .flatMap(order ->
                reserveInventory(dto, storeId)
                        .then(updateStatus(order, storeId, OrderStatus.INVENTORY_RESERVED))
                        .thenReturn(order)
        )
        // 4️⃣ Initiate payment
        .flatMap(order ->
                initiatePayment(order, storeId)
                        .then(updateStatus(order, storeId, OrderStatus.PAYMENT_PENDING))
                        .thenReturn(order)
        );
    }

    // ---------------------------------------------------------
    // FINALIZE PAYMENT (Payment service callback)
    // ---------------------------------------------------------
    @Override
    public Mono<Order> finalizePayment(Long orderId, Long storeId, boolean success) {

        OrderStatus initialStatus =
                success ? OrderStatus.PAYMENT_COMPLETED : OrderStatus.PAYMENT_FAILED;

        return Mono.fromCallable(() ->
                domainService.updateStatus(orderId, storeId, initialStatus)
        )
        .subscribeOn(Schedulers.boundedElastic())
        .flatMap(order -> {
            if (!success) {
                return Mono.just(order);
            }
            return Mono.fromCallable(() ->
                    domainService.updateStatus(orderId, storeId, OrderStatus.CONFIRMED)
            ).subscribeOn(Schedulers.boundedElastic());
        });
    }

    // ---------------------------------------------------------
    // CANCEL ORDER (Customer / Admin flow)
    // ---------------------------------------------------------
    @Override
    public Mono<Order> cancelOrder(Long orderId, Long userId, Long storeId) {

        return Mono.fromCallable(() ->
                domainService.get(orderId, storeId)
        )
        .subscribeOn(Schedulers.boundedElastic())

        // 1️⃣ Authorization: customer can cancel ONLY own order
        .flatMap(order -> {
            if (!order.getUserId().equals(userId)) {
                return Mono.error(
                        new SecurityException("Not allowed to cancel this order")
                );
            }
            return Mono.just(order);
        })

        // 2️⃣ Validate cancelability
        .flatMap(order -> {
            if (!cancellationService.isCancelable(order.getStatus())) {
                return Mono.error(
                        new IllegalStateException(
                                "Order cannot be cancelled in state " + order.getStatus()
                        )
                );
            }
            return Mono.just(order);
        })

        // 3️⃣ Rollback side effects
        .flatMap(order ->
                cancellationService.rollbackInventory(order, storeId)
                        .then(cancellationService.rollbackPayment(order, storeId))
                        .thenReturn(order)
        )

        // 4️⃣ Final status update
        .flatMap(order ->
                Mono.fromCallable(() ->
                        domainService.updateStatus(
                                order.getId(),
                                storeId,
                                OrderStatus.CANCELLED
                        )
                ).subscribeOn(Schedulers.boundedElastic())
        );
    }

    // ---------------------------------------------------------
    // Helper methods (private, orchestration-only)
    // ---------------------------------------------------------
    private Mono<Void> reserveInventory(OrderDTO dto, Long storeId) {
        return Flux.fromIterable(dto.items())
                .flatMap(item ->
                        inventoryClient.decrease(
                                item.productId(),
                                item.quantity(),
                                storeId
                        )
                )
                .then();
    }

    private Mono<Void> initiatePayment(Order order, Long storeId) {
        return paymentClient
                .initiatePayment(
                        order.getId(),
                        order.getUserId(),
                        order.getTotalAmount(),
                        storeId
                )
                .then();
    }

    private Mono<Order> updateStatus(Order order, Long storeId, OrderStatus status) {
        return Mono.fromCallable(() ->
                domainService.updateStatus(order.getId(), storeId, status)
        ).subscribeOn(Schedulers.boundedElastic());
    }
}
