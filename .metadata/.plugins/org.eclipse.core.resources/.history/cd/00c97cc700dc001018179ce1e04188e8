package com.ecommerce.orderservice.service.impl;

import com.ecommerce.orderservice.client.InventoryClient;
import com.ecommerce.orderservice.client.PaymentClient;
import com.ecommerce.orderservice.client.ProductClient;
import com.ecommerce.orderservice.dto.OrderDTO;
import com.ecommerce.orderservice.enums.OrderStatus;
import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.service.OrderCancellationService;
import com.ecommerce.orderservice.service.OrderDomainService;
import com.ecommerce.orderservice.service.OrderWorkflowService;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

@Service
public class OrderWorkflowServiceImpl implements OrderWorkflowService {

    private final OrderDomainService domain;
    private final ProductClient product;
    private final InventoryClient inventory;
    private final PaymentClient payment;
    private final OrderCancellationService cancellation;

    public OrderWorkflowServiceImpl(
            OrderDomainService domain,
            ProductClient product,
            InventoryClient inventory,
            PaymentClient payment,
            OrderCancellationService cancellation
    ) {
        this.domain = domain;
        this.product = product;
        this.inventory = inventory;
        this.payment = payment;
        this.cancellation = cancellation;
    }

    @Override
    public Mono<Order> createOrder(Long userId, Long storeId, OrderDTO dto) {

        return validateProducts(dto, storeId)
                .then(create(dto, userId, storeId))
                .flatMap(order ->
                        reserve(dto, storeId)
                                .then(update(order, storeId, OrderStatus.INVENTORY_RESERVED))
                                .thenReturn(order)
                )
                .flatMap(order ->
                        pay(order, storeId)
                                .then(update(order, storeId, OrderStatus.PAYMENT_PENDING))
                                .thenReturn(order)
                );
    }

    @Override
    public Mono<Order> finalizePayment(Long orderId, Long storeId, boolean success) {

        var status = success
                ? OrderStatus.PAYMENT_COMPLETED
                : OrderStatus.PAYMENT_FAILED;

        return update(orderId, storeId, status)
                .flatMap(order ->
                        success
                                ? update(orderId, storeId, OrderStatus.CONFIRMED)
                                : Mono.just(order)
                );
    }

    @Override
    public Mono<Order> cancelOrder(Long orderId, Long userId, Long storeId) {

        return get(orderId, storeId)
                .filter(order -> order.getUserId().equals(userId))
                .switchIfEmpty(Mono.error(new SecurityException("Unauthorized")))
                .filter(order -> cancellation.isCancelable(order.getStatus()))
                .switchIfEmpty(Mono.error(new IllegalStateException("Order not cancellable")))
                .flatMap(order ->
                        cancellation.rollbackInventory(order, storeId)
                                .then(cancellation.rollbackPayment(order, storeId))
                                .then(update(order.getId(), storeId, OrderStatus.CANCELLED))
                );
    }

    private Mono<Void> validateProducts(OrderDTO dto, Long storeId) {
        return Flux.fromIterable(dto.items())
                .concatMap(item ->
                        product.getProduct(item.productId(), storeId)
                                .then()
                )
                .then();
    }



    private Mono<Order> create(OrderDTO dto, Long userId, Long storeId) {
        return Mono.fromCallable(() -> domain.create(dto, userId, storeId))
                .subscribeOn(Schedulers.boundedElastic());
    }

    private Mono<Void> reserve(OrderDTO dto, Long storeId) {
        return Flux.fromIterable(dto.items())
                .flatMap(item -> inventory.decrease(item.productId(), item.quantity(), storeId))
                .then();
    }

    private Mono<Void> pay(Order order, Long storeId) {
        return payment.initiatePayment(
                order.getId(),
                order.getUserId(),
                order.getTotalAmount(),
                storeId
        ).then();
    }

    private Mono<Order> update(Order order, Long storeId, OrderStatus status) {
        return update(order.getId(), storeId, status);
    }

    private Mono<Order> update(Long orderId, Long storeId, OrderStatus status) {
        return Mono.fromCallable(() -> domain.updateStatus(orderId, storeId, status))
                .subscribeOn(Schedulers.boundedElastic());
    }

    private Mono<Order> get(Long orderId, Long storeId) {
        return Mono.fromCallable(() -> domain.get(orderId, storeId))
                .subscribeOn(Schedulers.boundedElastic());
    }
}
