package com.ecommerce.apigateway.exception;

import java.util.UUID;
import java.util.concurrent.TimeoutException;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.server.ResponseStatusException;

import com.ecommerce.apigateway.constants.GatewayErrorCodes;
import com.ecommerce.apigateway.constants.GatewayMessages;
import com.ecommerce.apigateway.constants.GatewayStatus;
import com.ecommerce.apigateway.model.GatewayErrorResponse;

import io.github.resilience4j.ratelimiter.RequestNotPermitted;

@RestControllerAdvice
public class GatewayGlobalExceptionHandler {

    private String traceId() {
        return UUID.randomUUID().toString();
    }

    private ResponseEntity<GatewayErrorResponse> build(HttpStatus status,
                                                       GatewayStatus gwStatus,
                                                       String errorCode,
                                                       String message) {

        GatewayErrorResponse response = new GatewayErrorResponse(
                "apigateway",
                gwStatus,
                errorCode,
                message,
                traceId()
        );

        return ResponseEntity.status(status).body(response);
    }


    @ExceptionHandler(ResponseStatusException.class)  // often thrown by filters
    public ResponseEntity<GatewayErrorResponse> handleStatusException(ResponseStatusException ex) {

        if (ex.getStatusCode() == HttpStatus.UNAUTHORIZED) {
            return build(HttpStatus.UNAUTHORIZED,
                    GatewayStatus.DOWN,
                    GatewayErrorCodes.JWT_INVALID,
                    GatewayMessages.JWT_INVALID);
        }

        if (ex.getStatusCode() == HttpStatus.BAD_REQUEST) {
            return build(HttpStatus.BAD_REQUEST,
                    GatewayStatus.DOWN,
                    GatewayErrorCodes.BAD_REQUEST,
                    GatewayMessages.BAD_REQUEST);
        }
        HttpStatus status = HttpStatus.resolve(ex.getStatusCode().value());
        return build(status, GatewayStatus.DOWN,
                GatewayErrorCodes.BAD_REQUEST,
                ex.getReason());
    }

    // --------------------------------------------------------
    // RateLimiter exception (RequestRateLimiter filter)
    // --------------------------------------------------------

    @ExceptionHandler(RequestNotPermitted.class)
    public ResponseEntity<GatewayErrorResponse> handleRateLimiter(RequestNotPermitted ex) {
        return build(HttpStatus.TOO_MANY_REQUESTS,
                GatewayStatus.DOWN,
                GatewayErrorCodes.RATE_LIMITED,
                GatewayMessages.RATE_LIMITED);
    }

    // --------------------------------------------------------
    // Timeout from WebFlux / WebClient / Resilience4j
    // --------------------------------------------------------

    @ExceptionHandler(java.util.concurrent.TimeoutException.class)
    public ResponseEntity<GatewayErrorResponse> handleTimeout(TimeoutException ex) {
        return build(HttpStatus.GATEWAY_TIMEOUT,
                GatewayStatus.DOWN,
                GatewayErrorCodes.TIMEOUT,
                GatewayMessages.TIMEOUT);
    }

    // --------------------------------------------------------
    // Circuit Breaker Open
    // --------------------------------------------------------

    @ExceptionHandler(io.github.resilience4j.circuitbreaker.CallNotPermittedException.class)
    public ResponseEntity<GatewayErrorResponse> handleCircuitOpen(
            io.github.resilience4j.circuitbreaker.CallNotPermittedException ex) {

        return build(HttpStatus.SERVICE_UNAVAILABLE,
                GatewayStatus.DOWN,
                GatewayErrorCodes.CIRCUIT_OPEN,
                GatewayMessages.CIRCUIT_OPEN);
    }

    // --------------------------------------------------------
    // OTHER EXCEPTIONS (fallback)
    // --------------------------------------------------------

    @ExceptionHandler(Exception.class)
    public ResponseEntity<GatewayErrorResponse> handleGeneric(Exception ex) {
        return build(HttpStatus.INTERNAL_SERVER_ERROR,
                GatewayStatus.DOWN,
                GatewayErrorCodes.SERVICE_UNAVAILABLE,
                GatewayMessages.SERVICE_UNAVAILABLE);
    }
}
