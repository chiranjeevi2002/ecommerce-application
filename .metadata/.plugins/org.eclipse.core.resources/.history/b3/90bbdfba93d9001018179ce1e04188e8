package com.ecommerce.userservice.service.admin.impl;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.ecommerce.userservice.dto.RoleSummary;
import com.ecommerce.userservice.dto.UserResponse;
import com.ecommerce.userservice.dto.UserRoleUpdateRequest;
import com.ecommerce.userservice.exception.BadRequestException;
import com.ecommerce.userservice.exception.NotFoundException;
import com.ecommerce.userservice.model.Role;
import com.ecommerce.userservice.model.User;
import com.ecommerce.userservice.repository.RoleRepository;
import com.ecommerce.userservice.repository.UserRepository;
import com.ecommerce.userservice.service.admin.UserAdminService;

@Service
@Transactional
public class UserAdminServiceImpl implements UserAdminService {

	private final UserRepository userRepository;
	private final RoleRepository roleRepository;

	public UserAdminServiceImpl(UserRepository userRepository, RoleRepository roleRepository) {
		this.userRepository = userRepository;
		this.roleRepository = roleRepository;
	}

	@Override
	public List<UserResponse> listUsers(Integer page, Integer size, String q, Long storeId) {
		int p = page == null ? 0 : Math.max(page, 0);
		int s = size == null ? 20 : Math.min(Math.max(size, 1), 100);

		PageRequest pageable = PageRequest.of(p, s, Sort.by("id").descending());

		Page<User> result;

		if (q != null && !q.isBlank()) {
			result = userRepository.searchByUsernameOrEmail(q, pageable);
		} else if (storeId != null) {
			result = userRepository.findAllByStoreId(storeId, pageable);
		} else {
			result = userRepository.findAll(pageable);
		}

		return result.stream().map(this::toResponse).collect(Collectors.toList());
	}

	@Override
	public UserResponse getUser(Long userId) {
		User user = userRepository.findById(userId)
				.orElseThrow(() -> new NotFoundException("User not found: " + userId));
		return toResponse(user);
	}

	@Override
	public UserResponse updateUserRoles(UserRoleUpdateRequest request) {

		if (request.roleIds() == null || request.roleIds().isEmpty()) {
			throw new BadRequestException("roleIds must not be empty");
		}

		User user = userRepository.findById(request.userId())
				.orElseThrow(() -> new NotFoundException("User not found: " + request.userId()));

		if (request.storeId() != null && !request.storeId().equals(user.getStoreId())) {
			throw new BadRequestException("User does not belong to this store");
		}

		Set<Role> roles = request.roleIds().stream().map(
				id -> roleRepository.findById(id).orElseThrow(() -> new BadRequestException("Invalid role id: " + id)))
				.collect(Collectors.toSet());

		user.setRoles(roles);
		return toResponse(user);
	}

	@Override
	public List<RoleSummary> listAllRoles() {
		return roleRepository.findAll(Sort.by("id")).stream().map(r -> new RoleSummary(r.getId(), r.getName()))
				.collect(Collectors.toList());
	}

	private UserResponse toResponse(User user) {
		Set<String> roles = user.getRoles().stream().map(Role::getName).collect(Collectors.toSet());

		return new UserResponse(user.getId(), user.getUsername(), user.getEmail(), user.getStoreId(), roles);
	}
}
