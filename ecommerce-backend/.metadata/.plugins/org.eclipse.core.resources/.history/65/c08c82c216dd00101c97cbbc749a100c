package com.ecommerce.orderservice.service.impl;

import org.springframework.stereotype.Service;

import com.ecommerce.common.webflux.context.ReactiveContextHolder;
import com.ecommerce.orderservice.client.InventoryClient;
import com.ecommerce.orderservice.client.PaymentClient;
import com.ecommerce.orderservice.client.ProductClient;
import com.ecommerce.orderservice.dto.OrderDTO;
import com.ecommerce.orderservice.dto.ProductValidationResult;
import com.ecommerce.orderservice.enums.OrderStatus;
import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.service.OrderCancellationService;
import com.ecommerce.orderservice.service.OrderDomainService;
import com.ecommerce.orderservice.service.OrderWorkflowService;
import com.ecommerce.orderservice.service.workflow.WorkflowContext;
import com.ecommerce.orderservice.service.workflow.WorkflowStep;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

@Service
public class OrderWorkflowServiceImpl implements OrderWorkflowService {

    private final OrderDomainService domain;
    private final ProductClient product;
    private final InventoryClient inventory;
    private final PaymentClient payment;
    private final OrderCancellationService cancellation;

    public OrderWorkflowServiceImpl(
            OrderDomainService domain,
            ProductClient product,
            InventoryClient inventory,
            PaymentClient payment,
            OrderCancellationService cancellation
    ) {
        this.domain = domain;
        this.product = product;
        this.inventory = inventory;
        this.payment = payment;
        this.cancellation = cancellation;
    }

    // =========================================================
    // CREATE ORDER WORKFLOW
    // =========================================================

    @Override
    public Mono<Order> createOrder(OrderDTO dto) {

        return ReactiveContextHolder.get()
                .map(ctx -> WorkflowContext.start(ctx.userId(), ctx.storeId()))
                .flatMap(ctx -> executeCreateWorkflow(dto, ctx))
                .map(WorkflowContext::order);
    }

    private Mono<WorkflowContext> executeCreateWorkflow(
            OrderDTO dto,
            WorkflowContext ctx
    ) {

        return validateProducts(dto)
                .then(createOrder(dto))
                .flatMap(reserveInventory(dto))
                .flatMap(initiatePayment())
                .map(updated -> updated.markCompleted("ORDER_WORKFLOW_DONE"));
    }

    // =========================================================
    // WORKFLOW STEPS (CLEAR & SMALL)
    // =========================================================

    private Mono<Void> validateProducts(OrderDTO dto) {

        var productIds = dto.items()
                .stream()
                .map(i -> i.productId())
                .toList();

        return product.validateProducts(null, productIds) // storeId already in headers
                .filter(ProductValidationResult::valid)
                .switchIfEmpty(Mono.error(
                        new IllegalStateException("Invalid products in order")
                ))
                .then();
    }

    private Mono<WorkflowContext> createOrder(OrderDTO dto) {

        return Mono.fromCallable(() ->
                        domain.create(dto, null, null)
                )
                .subscribeOn(Schedulers.boundedElastic())
                .map(order -> WorkflowContext
                        .start(order.getUserId(), order.getStoreId())
                        .withOrder(order)
                        .markCompleted("ORDER_CREATED")
                );
    }

    private WorkflowStep reserveInventory(OrderDTO dto) {

        return ctx -> Flux.fromIterable(dto.items())
                .flatMap(i ->
                        inventory.decrease(
                                i.productId(),
                                i.quantity(),
                                ctx.storeId()
                        )
                )
                .then(updateStatus(ctx, OrderStatus.INVENTORY_RESERVED))
                .map(updated -> updated.markCompleted("INVENTORY_RESERVED"));
    }

    private WorkflowStep initiatePayment() {

        return ctx -> payment.initiatePayment(
                        ctx.order().getId(),
                        ctx.order().getUserId(),
                        ctx.order().getTotalAmount(),
                        ctx.storeId()
                )
                .then(updateStatus(ctx, OrderStatus.PAYMENT_PENDING))
                .map(updated -> updated.markCompleted("PAYMENT_INITIATED"));
    }

    // =========================================================
    // SHARED HELPERS
    // =========================================================

    private Mono<WorkflowContext> updateStatus(
            WorkflowContext ctx,
            OrderStatus status
    ) {
        return Mono.fromCallable(() ->
                        domain.updateStatus(
                                ctx.order().getId(),
                                ctx.storeId(),
                                status
                        )
                )
                .subscribeOn(Schedulers.boundedElastic())
                .map(updated -> ctx.withOrder(updated));
    }

    // =========================================================
    // OTHER WORKFLOWS (UNCHANGED LOGIC, CONTEXT SAFE)
    // =========================================================

    @Override
    public Mono<Order> finalizePayment(Long orderId, Long storeId, boolean success) {

        var finalStatus = success
                ? OrderStatus.CONFIRMED
                : OrderStatus.PAYMENT_FAILED;

        return Mono.fromCallable(() ->
                        domain.updateStatus(orderId, storeId, finalStatus)
                )
                .subscribeOn(Schedulers.boundedElastic());
    }

    @Override
    public Mono<Order> cancelOrder(Long orderId, Long userId, Long storeId) {

        return Mono.fromCallable(() -> domain.get(orderId, storeId))
                .subscribeOn(Schedulers.boundedElastic())
                .filter(o -> o.getUserId().equals(userId))
                .switchIfEmpty(Mono.error(new SecurityException("Unauthorized")))
                .filter(o -> cancellation.isCancelable(o.getStatus()))
                .switchIfEmpty(Mono.error(
                        new IllegalStateException("Order not cancellable")
                ))
                .flatMap(o ->
                        cancellation.rollbackInventory(o, storeId)
                                .then(cancellation.rollbackPayment(o, storeId))
                                .then(Mono.fromCallable(() ->
                                        domain.updateStatus(
                                                o.getId(),
                                                storeId,
                                                OrderStatus.CANCELLED
                                        )
                                ).subscribeOn(Schedulers.boundedElastic()))
                );
    }
}
