package com.ecommerce.orderservice.service.impl;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Service;

import com.ecommerce.common.core.workflow.OrderWorkflowStep;
import com.ecommerce.common.webflux.context.ReactiveContextHolder;
import com.ecommerce.orderservice.client.InventoryClient;
import com.ecommerce.orderservice.client.PaymentClient;
import com.ecommerce.orderservice.client.ProductClient;
import com.ecommerce.orderservice.dto.OrderDTO;
import com.ecommerce.orderservice.dto.ProductValidationResult;
import com.ecommerce.orderservice.enums.OrderStatus;
import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.service.OrderCancellationService;
import com.ecommerce.orderservice.service.OrderDomainService;
import com.ecommerce.orderservice.service.OrderWorkflowService;
import com.ecommerce.orderservice.service.workflow.WorkflowContext;
import com.ecommerce.orderservice.service.workflow.WorkflowStep;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

@Service
public class OrderWorkflowServiceImpl implements OrderWorkflowService {

    private final OrderDomainService domainService;
    private final ProductClient productClient;
    private final InventoryClient inventoryClient;
    private final PaymentClient paymentClient;
    private final OrderCancellationService cancellationService;

    public OrderWorkflowServiceImpl(
            OrderDomainService domainService,
            ProductClient productClient,
            InventoryClient inventoryClient,
            PaymentClient paymentClient,
            OrderCancellationService cancellationService
    ) {
        this.domainService = domainService;
        this.productClient = productClient;
        this.inventoryClient = inventoryClient;
        this.paymentClient = paymentClient;
        this.cancellationService = cancellationService;
    }

    // =========================================================
    // CREATE ORDER WORKFLOW
    // =========================================================

    @Override
    public Mono<Order> createOrder(OrderDTO dto) {

        return ReactiveContextHolder.get()
                .map(ctx -> WorkflowContext.start(ctx.userId(), ctx.storeId(), ctx.traceId()))
                .flatMap(ctx -> executeCreateWorkflow(dto, ctx))
                .map(WorkflowContext::order);
    }

    private Mono<WorkflowContext> executeCreateWorkflow(
            OrderDTO dto,
            WorkflowContext context
    ) {

        return validateProducts(dto, context)
                .then(createOrderStep(dto).execute(context))
                .flatMap(ctx -> reserveInventoryStep(dto).execute(ctx))
                .flatMap(ctx -> initiatePaymentStep().execute(ctx));
    }

    // =========================================================
    // WORKFLOW STEPS
    // =========================================================

    private Mono<Void> validateProducts(
            OrderDTO dto,
            WorkflowContext context
    ) {

        List<Long> productIds = extractProductIds(dto);

        return productClient
                .validateProducts(context.storeId(), productIds)
                .filter(ProductValidationResult::valid)
                .switchIfEmpty(Mono.error(
                        new IllegalStateException("Invalid products in order")
                ))
                .then();
    }

    private WorkflowStep createOrderStep(OrderDTO dto) {

        return ctx ->
                Mono.fromCallable(() ->
                                domainService.create(dto, ctx.userId(), ctx.storeId())
                        )
                        .subscribeOn(Schedulers.boundedElastic())
                        .map(order ->
                                ctx.withOrder(order)
                                   .markCompleted(OrderWorkflowStep.CREATE_ORDER.name())
                        );
    }

    private WorkflowStep reserveInventoryStep(OrderDTO dto) {

        return ctx ->
                Flux.fromIterable(dto.items())
                        .flatMap(item ->
                                inventoryClient.decrease(
                                        item.productId(),
                                        item.quantity(),
                                        ctx.storeId()
                                )
                        )
                        .then(updateOrderStatus(ctx, OrderStatus.INVENTORY_RESERVED))
                        .map(updated ->
                                updated.markCompleted(
                                        OrderWorkflowStep.RESERVE_INVENTORY.name()
                                )
                        );
    }

    private WorkflowStep initiatePaymentStep() {

        return ctx ->
                paymentClient
                        .initiatePayment(
                                ctx.order().getId(),
                                ctx.order().getUserId(),
                                ctx.order().getTotalAmount(),
                                ctx.storeId()
                        )
                        .then(updateOrderStatus(ctx, OrderStatus.PAYMENT_PENDING))
                        .map(updated ->
                                updated.markCompleted(
                                        OrderWorkflowStep.INITIATE_PAYMENT.name()
                                )
                        );
    }

    // =========================================================
    // SHARED HELPERS
    // =========================================================

    private Mono<WorkflowContext> updateOrderStatus(
            WorkflowContext context,
            OrderStatus status
    ) {

        return Mono.fromCallable(() ->
                        domainService.updateStatus(
                                context.order().getId(),
                                context.storeId(),
                                status
                        )
                )
                .subscribeOn(Schedulers.boundedElastic())
                .map(context::withOrder);
    }

    private List<Long> extractProductIds(OrderDTO dto) {

        List<Long> ids = new ArrayList<>();

        for (int i = 0; i < dto.items().size(); i++) {
            ids.add(dto.items().get(i).productId());
        }

        return ids;
    }

    // =========================================================
    // OTHER WORKFLOWS
    // =========================================================

    @Override
    public Mono<Order> finalizePayment(
            Long orderId,
            Long storeId,
            boolean success
    ) {

        OrderStatus status = success
                ? OrderStatus.CONFIRMED
                : OrderStatus.PAYMENT_FAILED;

        return Mono.fromCallable(() ->
                        domainService.updateStatus(orderId, storeId, status)
                )
                .subscribeOn(Schedulers.boundedElastic());
    }

    @Override
    public Mono<Order> cancelOrder(
            Long orderId,
            Long userId,
            Long storeId
    ) {

        return Mono.fromCallable(() ->
                        domainService.get(orderId, storeId)
                )
                .subscribeOn(Schedulers.boundedElastic())
                .filter(order -> order.getUserId().equals(userId))
                .switchIfEmpty(Mono.error(
                        new SecurityException("Unauthorized order cancellation")
                ))
                .filter(order -> cancellationService.isCancelable(order.getStatus()))
                .switchIfEmpty(Mono.error(
                        new IllegalStateException("Order cannot be cancelled")
                ))
                .flatMap(order ->
                        cancellationService.rollbackInventory(order, storeId)
                                .then(cancellationService.rollbackPayment(order, storeId))
                                .then(Mono.fromCallable(() ->
                                        domainService.updateStatus(
                                                order.getId(),
                                                storeId,
                                                OrderStatus.CANCELLED
                                        )
                                ).subscribeOn(Schedulers.boundedElastic()))
                );
    }
}
