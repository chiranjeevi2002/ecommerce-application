package com.ecommerce.orderservice.service.impl;

import org.springframework.stereotype.Service;

import com.ecommerce.common.webflux.context.ReactiveContextHolder;
import com.ecommerce.orderservice.client.InventoryClient;
import com.ecommerce.orderservice.client.PaymentClient;
import com.ecommerce.orderservice.client.ProductClient;
import com.ecommerce.orderservice.dto.OrderDTO;
import com.ecommerce.orderservice.dto.ProductValidationResult;
import com.ecommerce.orderservice.enums.OrderStatus;
import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.service.OrderCancellationService;
import com.ecommerce.orderservice.service.OrderDomainService;
import com.ecommerce.orderservice.service.OrderWorkflowService;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

@Service
public class OrderWorkflowServiceImpl implements OrderWorkflowService {

    private final OrderDomainService domain;
    private final ProductClient product;
    private final InventoryClient inventory;
    private final PaymentClient payment;
    private final OrderCancellationService cancellation;

    public OrderWorkflowServiceImpl(
            OrderDomainService domain,
            ProductClient product,
            InventoryClient inventory,
            PaymentClient payment,
            OrderCancellationService cancellation
    ) {
        this.domain = domain;
        this.product = product;
        this.inventory = inventory;
        this.payment = payment;
        this.cancellation = cancellation;
    }

    @Override
    public Mono<Order> createOrder(OrderDTO dto) {

        return ReactiveContextHolder.get()
                .flatMap(ctx -> executeCreateWorkflow(dto, ctx.userId(), ctx.storeId()));
    }

    private Mono<Order> executeCreateWorkflow(
            OrderDTO dto,
            Long userId,
            Long storeId
    ) {

        return validateProducts(dto, storeId)
                .then(createOrder(dto, userId, storeId))
                .flatMap(reserveInventory(dto, storeId))
                .flatMap(initiatePayment(storeId));
    }

    /* ===== Workflow Steps ===== */

    private Mono<Void> validateProducts(OrderDTO dto, Long storeId) {
        var productIds = dto.items().stream().map(i -> i.productId()).toList();

        return product.validateProducts(storeId, productIds)
                .filter(ProductValidationResult::valid)
                .switchIfEmpty(Mono.error(
                        new IllegalStateException("Invalid products in order")
                ))
                .then();
    }

    private Mono<Order> createOrder(
            OrderDTO dto,
            Long userId,
            Long storeId
    ) {
        return Mono.fromCallable(() -> domain.create(dto, userId, storeId))
                .subscribeOn(Schedulers.boundedElastic());
    }

    private WorkflowStep<Order> reserveInventory(OrderDTO dto, Long storeId) {
        return order -> Flux.fromIterable(dto.items())
                .flatMap(i ->
                        inventory.decrease(
                                i.productId(),
                                i.quantity(),
                                storeId
                        )
                )
                .then(updateStatus(order, storeId, OrderStatus.INVENTORY_RESERVED));
    }

    private WorkflowStep<Order> initiatePayment(Long storeId) {
        return order -> payment.initiatePayment(
                        order.getId(),
                        order.getUserId(),
                        order.getTotalAmount(),
                        storeId
                )
                .then(updateStatus(order, storeId, OrderStatus.PAYMENT_PENDING));
    }

    /* ===== Shared Helpers ===== */

    private Mono<Order> updateStatus(
            Order order,
            Long storeId,
            OrderStatus status
    ) {
        return Mono.fromCallable(
                        () -> domain.updateStatus(order.getId(), storeId, status)
                )
                .subscribeOn(Schedulers.boundedElastic());
    }

    @Override
    public Mono<Order> finalizePayment(Long orderId, Long storeId, boolean success) {

        var finalStatus = success
                ? OrderStatus.CONFIRMED
                : OrderStatus.PAYMENT_FAILED;

        return Mono.fromCallable(() ->
                        domain.updateStatus(orderId, storeId, finalStatus)
                )
                .subscribeOn(Schedulers.boundedElastic());
    }

    @Override
    public Mono<Order> cancelOrder(Long orderId, Long userId, Long storeId) {

        return Mono.fromCallable(() -> domain.get(orderId, storeId))
                .subscribeOn(Schedulers.boundedElastic())
                .filter(o -> o.getUserId().equals(userId))
                .switchIfEmpty(Mono.error(new SecurityException("Unauthorized")))
                .filter(o -> cancellation.isCancelable(o.getStatus()))
                .switchIfEmpty(Mono.error(
                        new IllegalStateException("Order not cancellable")
                ))
                .flatMap(o ->
                        cancellation.rollbackInventory(o, storeId)
                                .then(cancellation.rollbackPayment(o, storeId))
                                .then(updateStatus(o, storeId, OrderStatus.CANCELLED))
                );
    }
}

